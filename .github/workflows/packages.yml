name: Create Platform Packages

permissions:
  contents: write

on:
  # Triggered after a release is created
  release:
    types: [created]
  # Manual trigger
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to use for packaging (without v prefix)'
        required: true
        default: ''

jobs:
  create-debian-package:
    name: Create Debian Package
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [amd64, arm64, i386]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get latest release
        id: get_release
        if: github.event.inputs.version == ''
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/releases/latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            # Extract version from the release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Extract from API response with safer parsing
            RESPONSE='${{ steps.get_release.outputs.data }}'
            TAG_NAME=$(echo "$RESPONSE" | grep -o '"tag_name": *"[^"]*"' | cut -d'"' -f4)
            VERSION=${TAG_NAME#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"

      - name: Download Linux binary
        uses: robinraju/release-downloader@v1.8
        with:
          repository: ${{ github.repository }}
          tag: "v${{ steps.extract_version.outputs.VERSION }}"
          fileName: "apisnip-linux-${{ matrix.arch == 'amd64' && 'x86_64' || (matrix.arch == 'i386' && 'i686' || matrix.arch) }}.tar.gz"
          out-file-path: ./downloaded
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract binary
        run: |
          mkdir -p pkg/usr/bin
          mkdir -p pkg/usr/share/doc/apisnip
          tar -xzf ./downloaded/apisnip-linux-*.tar.gz -C ./pkg/usr/bin apisnip
          cp README.md LICENSE pkg/usr/share/doc/apisnip/ || true
          chmod +x pkg/usr/bin/apisnip

      - name: Create Debian package
        id: create_deb
        run: |
          # Map GitHub Action arch to Debian arch
          DEBIAN_ARCH="${{ matrix.arch }}"
          if [ "${{ matrix.arch }}" = "i386" ]; then
            DEBIAN_ARCH="i386"
          fi
          
          # Create Debian control file
          mkdir -p pkg/DEBIAN
          cat > pkg/DEBIAN/control << EOF
          Package: apisnip
          Version: ${{ steps.extract_version.outputs.VERSION }}
          Section: utils
          Priority: optional
          Architecture: ${DEBIAN_ARCH}
          Maintainer: Michiel Roos <apisnip.zumble.frap@michielroos.com>
          Description: A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size
           ApiSnip is a command-line tool that helps you trim down large OpenAPI specifications
           to only the parts you need. It provides a user-friendly terminal interface for
           selecting specific endpoints and data models.
          EOF
          
          # Build the package
          DEB_FILENAME="apisnip_${{ steps.extract_version.outputs.VERSION }}_${DEBIAN_ARCH}.deb"
          dpkg-deb --build pkg "${DEB_FILENAME}"
          echo "DEB_FILENAME=${DEB_FILENAME}" >> $GITHUB_OUTPUT
          
          # Create checksum
          sha256sum "${DEB_FILENAME}" > "${DEB_FILENAME}.sha256"

      - name: Upload Debian package to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.create_deb.outputs.DEB_FILENAME }}
            ${{ steps.create_deb.outputs.DEB_FILENAME }}.sha256
          tag_name: v${{ steps.extract_version.outputs.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-rpm-package:
    name: Create RPM Package
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [x86_64, aarch64]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Get latest release
        id: get_release
        if: github.event.inputs.version == ''
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/releases/latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            # Extract version from the release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Extract from API response with safer parsing
            RESPONSE='${{ steps.get_release.outputs.data }}'
            TAG_NAME=$(echo "$RESPONSE" | grep -o '"tag_name": *"[^"]*"' | cut -d'"' -f4)
            VERSION=${TAG_NAME#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"
          
      - name: Install RPM build tools
        run: sudo apt-get update && sudo apt-get install -y rpm

      - name: Download Linux binary
        uses: robinraju/release-downloader@v1.8
        with:
          repository: ${{ github.repository }}
          tag: "v${{ steps.extract_version.outputs.VERSION }}"
          fileName: "apisnip-linux-${{ matrix.arch == 'aarch64' && 'arm64' || matrix.arch }}.tar.gz"
          out-file-path: ./downloaded
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify downloaded file
        run: |
          ls -la ./downloaded/
          if [ ! -s ./downloaded/apisnip-linux-*.tar.gz ]; then
            echo "Error: Downloaded file is empty or does not exist"
            exit 1
          fi
          file ./downloaded/apisnip-linux-*.tar.gz

      - name: Setup RPM build environment
        run: |
          mkdir -p ~/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
          mkdir -p ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}
          
          # Extract binary
          mkdir -p ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}/usr/bin
          mkdir -p ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}/usr/share/doc/apisnip
          tar -xzf ./downloaded/apisnip-linux-*.tar.gz -C ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}/usr/bin apisnip
          cp README.md LICENSE ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}/usr/share/doc/apisnip/ || true
          chmod +x ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}/usr/bin/apisnip
          
          # Create source tarball
          cd ~/rpmbuild/SOURCES
          tar -czf apisnip-${{ steps.extract_version.outputs.VERSION }}.tar.gz apisnip-${{ steps.extract_version.outputs.VERSION }}

      - name: Create spec file
        run: |
          cat > ~/rpmbuild/SPECS/apisnip.spec << EOF
          Name:           apisnip
          Version:        ${{ steps.extract_version.outputs.VERSION }}
          Release:        1%{?dist}
          Summary:        A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size
          
          License:        MIT
          URL:            https://github.com/Tuurlijk/apisnip
          Source0:        %{name}-%{version}.tar.gz
          
          # Specify architecture explicitly
          BuildArch:      ${{ matrix.arch }}
          
          %description
          ApiSnip is a command-line tool that helps you trim down large OpenAPI specifications
          to only the parts you need. It provides a user-friendly terminal interface for
          selecting specific endpoints and data models.
          
          %prep
          %setup -q
          
          %install
          mkdir -p %{buildroot}
          cp -a * %{buildroot}
          
          %files
          %{_bindir}/apisnip
          %doc %{_docdir}/apisnip/README.md
          %license %{_docdir}/apisnip/LICENSE
          
          %changelog
          * $(date '+%a %b %d %Y') GitHub Action <apisnip.zumble.frap@michielroos.com> - ${{ steps.extract_version.outputs.VERSION }}-1
          - Automated package build
          EOF

      - name: Build RPM package
        id: build_rpm
        run: |
          rpmbuild -ba ~/rpmbuild/SPECS/apisnip.spec || {
            echo "RPM build failed, checking issues..."
            cat ~/rpmbuild/SPECS/apisnip.spec
            ls -la ~/rpmbuild/SOURCES/
            echo "Contents of source tarball:"
            tar -tvzf ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}.tar.gz
            exit 1
          }
          
          # Find the built RPM
          RPM_PATH=$(find ~/rpmbuild/RPMS -name "*.rpm" | head -1)
          if [ -z "$RPM_PATH" ]; then
            echo "No RPM package found in the build directory"
            exit 1
          fi
          
          RPM_FILENAME=$(basename "$RPM_PATH")
          cp "$RPM_PATH" .
          
          # Create checksum
          sha256sum "${RPM_FILENAME}" > "${RPM_FILENAME}.sha256"
          
          echo "RPM_FILENAME=${RPM_FILENAME}" >> $GITHUB_OUTPUT

      - name: Upload RPM package to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.build_rpm.outputs.RPM_FILENAME }}
            ${{ steps.build_rpm.outputs.RPM_FILENAME }}.sha256
          tag_name: v${{ steps.extract_version.outputs.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-apk-package:
    name: Create Alpine Linux Package (APK)
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [x86_64, aarch64]
    container:
      image: alpine:latest
    steps:
      - name: Install build tools
        run: |
          apk add --no-cache alpine-sdk sudo tar curl jq bash file

      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            # Extract version from the release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # If we got here, we need to manually get the latest release
            REPO="${GITHUB_REPOSITORY}"
            GITHUB_API="https://api.github.com/repos/${REPO}/releases/latest"
            VERSION=$(curl -s ${GITHUB_API} | jq -r '.tag_name' | sed 's/^v//')
            echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          fi
          VERSION=$(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)
          echo "Using version: $VERSION"
          # Export as environment variable for easier use in subsequent steps
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Download Linux binary
        run: |
          mkdir -p downloaded
          ARCH_NAME="${{ matrix.arch }}"
          if [ "${{ matrix.arch }}" = "aarch64" ]; then
            ARCH_NAME="arm64"
          fi
          
          DOWNLOAD_URL="https://github.com/${GITHUB_REPOSITORY}/releases/download/v${VERSION}/apisnip-linux-${ARCH_NAME}.tar.gz"
          echo "Downloading from: $DOWNLOAD_URL"
          
          curl -L -o downloaded/apisnip-linux.tar.gz "$DOWNLOAD_URL"
          
          # Verify the download
          ls -la downloaded/
          file downloaded/apisnip-linux.tar.gz

      - name: Extract binary manually
        run: |
          mkdir -p pkg/usr/bin
          cd pkg
          
          # Extract the tar file directly
          BINARY_PATH="$(pwd)/usr/bin/apisnip"
          mkdir -p usr/bin
          
          cd ..
          tar -xvf downloaded/apisnip-linux.tar.gz -C pkg
          
          if [ -f "pkg/apisnip" ]; then
            # If the binary is directly at the root, move it to the right location
            mkdir -p pkg/usr/bin
            mv pkg/apisnip pkg/usr/bin/
          fi
          
          # Verify extraction
          find pkg -type f | sort
          
          # Copy binary to a known location for build step
          cp pkg/usr/bin/apisnip ./apisnip || { 
            echo "Binary not found at pkg/usr/bin/apisnip, checking other locations";
            find pkg -name "apisnip" -type f -exec cp {} ./apisnip \;
          }
          
          if [ ! -f "./apisnip" ]; then
            echo "Failed to locate the apisnip binary after extraction"
            exit 1
          fi
          
          chmod +x ./apisnip

      - name: Setup APK build environment
        run: |
          # Create build directories
          mkdir -p ~/apkbuild/{src,pkg,keys}
          
          # Generate keys for signing packages
          abuild-keygen -a -n -q
          
          # Set up APKBUILD file
          mkdir -p ~/apkbuild/src/apisnip
          cd ~/apkbuild/src/apisnip
          
          cat > APKBUILD << EOF
          # Maintainer: Michiel Roos <apisnip.zumble.frap@michielroos.com>
          pkgname=apisnip
          pkgver=${VERSION}
          pkgrel=0
          pkgdesc="A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size"
          url="https://github.com/Tuurlijk/apisnip"
          arch="${{ matrix.arch }}"
          license="MIT"
          depends=""
          makedepends=""
          install=""
          subpackages=""
          source=""
          
          package() {
            mkdir -p "\$pkgdir/usr/bin"
            mkdir -p "\$pkgdir/usr/share/doc/apisnip"
            cp \$startdir/../../apisnip "\$pkgdir/usr/bin/"
            chmod +x "\$pkgdir/usr/bin/apisnip"
            cp \$startdir/../../../README.md \$startdir/../../../LICENSE "\$pkgdir/usr/share/doc/apisnip/" || true
          }
          EOF

      - name: Build APK package
        id: build_apk
        run: |
          cd ~/apkbuild/src/apisnip
          
          # Build the package
          abuild -F
          
          # Find the built APK
          APK_PATH=$(find /home/$(whoami)/packages -name "*.apk" | grep apisnip | head -1)
          
          if [ -z "$APK_PATH" ]; then
            echo "No APK package found in the build directory"
            ls -la /home/$(whoami)/packages
            abuild -v # Show more verbose output about what might have gone wrong
            exit 1
          fi
          
          APK_FILENAME=$(basename "$APK_PATH")
          
          # Copy the package
          cp "$APK_PATH" /github/workspace/
          
          # Create checksum
          cd /github/workspace
          sha256sum "${APK_FILENAME}" > "${APK_FILENAME}.sha256"
          
          echo "APK_FILENAME=${APK_FILENAME}" >> $GITHUB_OUTPUT

      - name: Upload APK package to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.build_apk.outputs.APK_FILENAME }}
            ${{ steps.build_apk.outputs.APK_FILENAME }}.sha256
          tag_name: v${{ env.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-macos-package:
    name: Create macOS Package
    runs-on: macos-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Get latest release
        id: get_release
        if: github.event.inputs.version == ''
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/releases/latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            # Extract version from the release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Extract from API response with safer parsing
            RESPONSE='${{ steps.get_release.outputs.data }}'
            TAG_NAME=$(echo "$RESPONSE" | grep -o '"tag_name": *"[^"]*"' | cut -d'"' -f4)
            VERSION=${TAG_NAME#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"

      - name: Download macOS binaries
        uses: robinraju/release-downloader@v1.8
        with:
          repository: ${{ github.repository }}
          tag: "v${{ steps.extract_version.outputs.VERSION }}"
          fileName: "apisnip-macos-*.tar.gz"
          out-file-path: ./downloaded
          token: ${{ secrets.GITHUB_TOKEN }}

      # Create DMG package
      - name: Create macOS DMG package
        id: create_dmg
        run: |
          # Create app structure
          mkdir -p ApiSnip.app/Contents/{MacOS,Resources}
          
          # Extract x86_64 binary (use arm64 if available)
          if [ -f "downloaded/apisnip-macos-arm64.tar.gz" ]; then
            tar -xzf downloaded/apisnip-macos-arm64.tar.gz -C ./
          else
            tar -xzf downloaded/apisnip-macos-x86_64.tar.gz -C ./
          fi
          
          # Copy binary to app bundle
          mv apisnip ApiSnip.app/Contents/MacOS/
          
          # Create Info.plist
          cat > ApiSnip.app/Contents/Info.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleExecutable</key>
              <string>apisnip</string>
              <key>CFBundleIdentifier</key>
              <string>com.michielroos.apisnip</string>
              <key>CFBundleName</key>
              <string>ApiSnip</string>
              <key>CFBundleVersion</key>
              <string>${{ steps.extract_version.outputs.VERSION }}</string>
              <key>CFBundleShortVersionString</key>
              <string>${{ steps.extract_version.outputs.VERSION }}</string>
          </dict>
          </plist>
          EOF
          
          # Create DMG
          hdiutil create -volname "ApiSnip" -srcfolder ApiSnip.app -ov -format UDZO apisnip-${{ steps.extract_version.outputs.VERSION }}.dmg
          
          # Create checksum
          shasum -a 256 apisnip-${{ steps.extract_version.outputs.VERSION }}.dmg > apisnip-${{ steps.extract_version.outputs.VERSION }}.dmg.sha256
          
          echo "DMG_FILENAME=apisnip-${{ steps.extract_version.outputs.VERSION }}.dmg" >> $GITHUB_OUTPUT

      # Create Homebrew Formula
      - name: Create Homebrew Formula
        id: create_homebrew
        run: |
          # Create formula directory
          mkdir -p homebrew-formula
          
          # Calculate SHA for macOS binaries
          ARM64_SHA=""
          X86_64_SHA=""
          
          if [ -f "downloaded/apisnip-macos-arm64.tar.gz" ]; then
            ARM64_SHA=$(shasum -a 256 downloaded/apisnip-macos-arm64.tar.gz | cut -d ' ' -f 1)
          fi
          
          if [ -f "downloaded/apisnip-macos-x86_64.tar.gz" ]; then
            X86_64_SHA=$(shasum -a 256 downloaded/apisnip-macos-x86_64.tar.gz | cut -d ' ' -f 1)
          fi
          
          # Create the formula file
          cat > homebrew-formula/apisnip.rb << EOF
          class Apisnip < Formula
            desc "A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size"
            homepage "https://github.com/Tuurlijk/apisnip"
            version "${{ steps.extract_version.outputs.VERSION }}"
            license "MIT"
            
            on_macos do
              on_arm do
                url "https://github.com/Tuurlijk/apisnip/releases/download/v${{ steps.extract_version.outputs.VERSION }}/apisnip-macos-arm64.tar.gz"
                sha256 "${ARM64_SHA}"
              end
              
              on_intel do
                url "https://github.com/Tuurlijk/apisnip/releases/download/v${{ steps.extract_version.outputs.VERSION }}/apisnip-macos-x86_64.tar.gz"
                sha256 "${X86_64_SHA}"
              end
            end
            
            on_linux do
              url "https://github.com/Tuurlijk/apisnip/releases/download/v${{ steps.extract_version.outputs.VERSION }}/apisnip-linux-x86_64.tar.gz"
            end
            
            def install
              bin.install "apisnip"
            end
            
            test do
              assert_match "ApiSnip ${{ steps.extract_version.outputs.VERSION }}", shell_output("#{bin}/apisnip --version", 2)
            end
          end
          EOF
          
          # Create a zip of the formula
          zip -r apisnip-homebrew-${{ steps.extract_version.outputs.VERSION }}.zip homebrew-formula/apisnip.rb
          
          echo "HOMEBREW_FORMULA=apisnip-homebrew-${{ steps.extract_version.outputs.VERSION }}.zip" >> $GITHUB_OUTPUT

      - name: Upload macOS packages to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.create_dmg.outputs.DMG_FILENAME }}
            ${{ steps.create_dmg.outputs.DMG_FILENAME }}.sha256
            ${{ steps.create_homebrew.outputs.HOMEBREW_FORMULA }}
          tag_name: v${{ steps.extract_version.outputs.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-aur-package:
    name: Create AUR Package
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Get latest release
        id: get_release
        if: github.event.inputs.version == ''
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/releases/latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            # Extract version from the release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Extract from API response with safer parsing
            RESPONSE='${{ steps.get_release.outputs.data }}'
            TAG_NAME=$(echo "$RESPONSE" | grep -o '"tag_name": *"[^"]*"' | cut -d'"' -f4)
            VERSION=${TAG_NAME#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"
          
      - name: Download source code
        run: |
          mkdir -p aur-package
          cd aur-package
          curl -L "https://github.com/${{ github.repository }}/archive/refs/tags/v${{ steps.extract_version.outputs.VERSION }}.tar.gz" -o "apisnip-${{ steps.extract_version.outputs.VERSION }}.tar.gz"
          
          # Calculate SHA256 sum
          SOURCE_SHA256=$(sha256sum "apisnip-${{ steps.extract_version.outputs.VERSION }}.tar.gz" | awk '{print $1}')
          echo "SOURCE_SHA256=${SOURCE_SHA256}" >> $GITHUB_ENV

      - name: Create PKGBUILD
        id: create_pkgbuild
        run: |
          cd aur-package
          
          cat > PKGBUILD << EOF
          # Maintainer: Michiel Roos <apisnip.zumble.frap@michielroos.com>
          
          pkgname=apisnip
          pkgver=${{ steps.extract_version.outputs.VERSION }}
          pkgrel=1
          pkgdesc="A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size"
          arch=('x86_64' 'aarch64')
          url="https://github.com/Tuurlijk/apisnip"
          license=('MIT')
          depends=()
          makedepends=('cargo')
          source=("\${pkgname}-\${pkgver}.tar.gz::https://github.com/Tuurlijk/apisnip/archive/refs/tags/v\${pkgver}.tar.gz")
          sha256sums=('${SOURCE_SHA256}')
          
          build() {
            cd "\${pkgname}-\${pkgver}"
            cargo build --release
          }
          
          package() {
            cd "\${pkgname}-\${pkgver}"
            install -Dm755 "target/release/\${pkgname}" "\${pkgdir}/usr/bin/\${pkgname}"
            install -Dm644 "LICENSE" "\${pkgdir}/usr/share/licenses/\${pkgname}/LICENSE"
            install -Dm644 "README.md" "\${pkgdir}/usr/share/doc/\${pkgname}/README.md"
          }
          EOF
          
          cat > .SRCINFO << EOF
          pkgbase = apisnip
          	pkgdesc = A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size
          	pkgver = ${{ steps.extract_version.outputs.VERSION }}
          	pkgrel = 1
          	url = https://github.com/Tuurlijk/apisnip
          	arch = x86_64
          	arch = aarch64
          	license = MIT
          	makedepends = cargo
          	source = apisnip-${{ steps.extract_version.outputs.VERSION }}.tar.gz::https://github.com/Tuurlijk/apisnip/archive/refs/tags/v${{ steps.extract_version.outputs.VERSION }}.tar.gz
          	sha256sums = ${SOURCE_SHA256}
          
          pkgname = apisnip
          EOF
          
          tar -czf apisnip-aur-${{ steps.extract_version.outputs.VERSION }}.tar.gz PKGBUILD .SRCINFO
          echo "AUR_PACKAGE=apisnip-aur-${{ steps.extract_version.outputs.VERSION }}.tar.gz" >> $GITHUB_OUTPUT

      - name: Upload AUR package to release
        uses: softprops/action-gh-release@v2
        with:
          files: aur-package/${{ steps.create_pkgbuild.outputs.AUR_PACKAGE }}
          tag_name: v${{ steps.extract_version.outputs.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      # Note: To actually publish to AUR, you would need to set up SSH keys
      # and use git to push to the AUR. This is not implemented here as it
      # requires AUR account credentials. 

  # Add a final job to organize release assets in the description
  organize-release-assets:
    name: Organize Release Assets
    needs: [create-debian-package, create-rpm-package, create-apk-package, create-macos-package, create-aur-package]
    runs-on: ubuntu-latest
    if: always() # Run even if some of the previous jobs failed
    steps:
      - name: Get Release Info
        id: get_release
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/releases/latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            RESPONSE='${{ steps.get_release.outputs.data }}'
            TAG_NAME=$(echo "$RESPONSE" | grep -o '"tag_name": *"[^"]*"' | cut -d'"' -f4)
            VERSION=${TAG_NAME#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"

      - name: Get All Assets
        id: get_assets
        run: |
          RELEASE_TAG="v${{ steps.extract_version.outputs.VERSION }}"
          ASSETS=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$RELEASE_TAG" \
            | jq -r '.assets[] | "\(.name) \(.browser_download_url)"')
          
          echo "ASSETS<<EOF" >> $GITHUB_ENV
          echo "$ASSETS" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Get Existing Release Info
        id: get_existing_release
        run: |
          RELEASE_TAG="v${{ steps.extract_version.outputs.VERSION }}"
          RELEASE_DATA=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$RELEASE_TAG")
          
          # Extract the current release body
          EXISTING_BODY=$(echo "$RELEASE_DATA" | jq -r '.body // ""')
          
          # Check if body already contains our asset tables (to avoid duplicates)
          if echo "$EXISTING_BODY" | grep -q "## Binary Downloads"; then
            # If our sections already exist, just preserve the original body
            echo "EXISTING_BODY<<EOF" >> $GITHUB_ENV
            echo "$EXISTING_BODY" >> $GITHUB_ENV 
            echo "EOF" >> $GITHUB_ENV
            echo "CONTAINS_ASSETS=true" >> $GITHUB_OUTPUT
          else
            # If our sections don't exist, we'll append them
            echo "EXISTING_BODY<<EOF" >> $GITHUB_ENV
            echo "$EXISTING_BODY" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "CONTAINS_ASSETS=false" >> $GITHUB_OUTPUT
          fi

      - name: Organize Assets by Category
        id: organize_assets
        if: steps.get_existing_release.outputs.CONTAINS_ASSETS != 'true'
        run: |
          # Function to create a category section with assets
          create_category() {
            local category=$1
            local pattern=$2
            local title=$3
            
            echo -e "### $title\n"
            
            # Filter assets matching the pattern and create markdown links
            matching_assets=$(echo "$ASSETS" | grep -i "$pattern" | grep -v "\.sha256$" | sort)
            if [ -z "$matching_assets" ]; then
              echo "No $category packages available."
            else
              echo "| Package | SHA256 |"
              echo "|---------|--------|"
              echo "$matching_assets" | while read -r line; do
                name=$(echo "$line" | awk '{print $1}')
                url=$(echo "$line" | awk '{print $2}')
                sha_line=$(echo "$ASSETS" | grep "${name}\.sha256")
                if [ -n "$sha_line" ]; then
                  sha_url=$(echo "$sha_line" | awk '{print $2}')
                  echo "| [$name]($url) | [SHA256]($sha_url) |"
                else
                  echo "| [$name]($url) | N/A |"
                fi
              done
            fi
            echo ""
          }
          
          # Generate description file for the assets
          cat > assets_section.md << EOF

          ## Binary Downloads
          
          $(create_category "Linux" "linux" "Linux Binaries")
          $(create_category "Windows" "windows" "Windows Binaries")
          $(create_category "macOS" "macos" "macOS Binaries")
          $(create_category "FreeBSD" "freebsd" "FreeBSD Binaries")
          $(create_category "NetBSD" "netbsd" "NetBSD Binaries")
          
          ## Package Downloads
          
          $(create_category "Debian" "_amd64\.deb\|_arm64\.deb\|_i386\.deb" "Debian/Ubuntu Packages (.deb)")
          $(create_category "RPM" "\.rpm" "Red Hat/Fedora/SUSE Packages (.rpm)")
          $(create_category "Alpine" "\.apk" "Alpine Linux Packages (.apk)")
          $(create_category "AUR" "aur" "Arch Linux Package (AUR)")
          $(create_category "Homebrew" "homebrew" "macOS Homebrew Formula")
          $(create_category "DMG" "\.dmg" "macOS Disk Image (.dmg)")
          EOF
          
          ASSETS_SECTION=$(cat assets_section.md)
          echo "assets_section<<EOF" >> $GITHUB_OUTPUT
          echo "$ASSETS_SECTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Combine existing body with asset tables
          if [ -n "$EXISTING_BODY" ]; then
            COMBINED_BODY="${EXISTING_BODY}${ASSETS_SECTION}"
          else
            COMBINED_BODY=$'## ApiSnip v${{ steps.extract_version.outputs.VERSION }}\n\nA terminal user interface (TUI) tool for trimming OpenAPI specifications down to size ✂️${ASSETS_SECTION}'
          fi
          
          echo "combined_body<<EOF" >> $GITHUB_OUTPUT
          echo "$COMBINED_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update Release Description
        if: steps.get_existing_release.outputs.CONTAINS_ASSETS != 'true'
        uses: octokit/request-action@v2.x
        with:
          route: PATCH /repos/${{ github.repository }}/releases/tags/v${{ steps.extract_version.outputs.VERSION }}
          body: ${{ steps.organize_assets.outputs.combined_body }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Log Status
        run: |
          if [ "${{ steps.get_existing_release.outputs.CONTAINS_ASSETS }}" == "true" ]; then
            echo "Release description already contains asset tables. No changes made."
          else
            echo "Release description updated with organized asset tables."
          fi 