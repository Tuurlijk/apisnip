name: Create Platform Packages

permissions:
  contents: write

on:
  # Triggered after a release is created
  release:
    types: [created]
  # Manual trigger
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to use for packaging (without v prefix)'
        required: true
        default: ''

jobs:
  create-debian-package:
    name: Create Debian Package
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [amd64, arm64, i386]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get latest release
        id: get_release
        if: github.event.inputs.version == ''
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/releases/latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            # Extract version from the release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Extract from API response with safer parsing
            RESPONSE='${{ steps.get_release.outputs.data }}'
            TAG_NAME=$(echo "$RESPONSE" | grep -o '"tag_name": *"[^"]*"' | cut -d'"' -f4)
            VERSION=${TAG_NAME#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"

      - name: Download Linux binary
        uses: robinraju/release-downloader@v1.8
        with:
          repository: ${{ github.repository }}
          tag: "v${{ steps.extract_version.outputs.VERSION }}"
          fileName: "apisnip-linux-${{ matrix.arch == 'amd64' && 'x86_64' || (matrix.arch == 'i386' && 'i686' || matrix.arch) }}.tar.gz"
          out-file-path: ./downloaded
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract binary
        run: |
          mkdir -p pkg/usr/bin
          mkdir -p pkg/usr/share/doc/apisnip
          tar -xzf ./downloaded/apisnip-linux-*.tar.gz -C ./pkg/usr/bin apisnip
          cp README.md LICENSE pkg/usr/share/doc/apisnip/ || true
          chmod +x pkg/usr/bin/apisnip

      - name: Create Debian package
        id: create_deb
        run: |
          # Map GitHub Action arch to Debian arch
          DEBIAN_ARCH="${{ matrix.arch }}"
          if [ "${{ matrix.arch }}" = "i386" ]; then
            DEBIAN_ARCH="i386"
          fi
          
          # Create Debian control file
          mkdir -p pkg/DEBIAN
          cat > pkg/DEBIAN/control << EOF
          Package: apisnip
          Version: ${{ steps.extract_version.outputs.VERSION }}
          Section: utils
          Priority: optional
          Architecture: ${DEBIAN_ARCH}
          Maintainer: Michiel Roos <apisnip.zumble.frap@michielroos.com>
          Description: A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size
           ApiSnip is a command-line tool that helps you trim down large OpenAPI specifications
           to only the parts you need. It provides a user-friendly terminal interface for
           selecting specific endpoints and data models.
          EOF
          
          # Build the package
          DEB_FILENAME="apisnip_${{ steps.extract_version.outputs.VERSION }}_${DEBIAN_ARCH}.deb"
          dpkg-deb --build pkg "${DEB_FILENAME}"
          echo "DEB_FILENAME=${DEB_FILENAME}" >> $GITHUB_OUTPUT
          
          # Create checksum
          sha256sum "${DEB_FILENAME}" > "${DEB_FILENAME}.sha256"

      - name: Upload Debian package to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.create_deb.outputs.DEB_FILENAME }}
            ${{ steps.create_deb.outputs.DEB_FILENAME }}.sha256
          tag_name: v${{ steps.extract_version.outputs.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-rpm-package:
    name: Create RPM Package
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # Only build for x86_64 as aarch64 is causing compatibility issues
        arch: [x86_64]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Get latest release
        id: get_release
        if: github.event.inputs.version == ''
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/releases/latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            # Extract version from the release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Extract from API response with safer parsing
            RESPONSE='${{ steps.get_release.outputs.data }}'
            TAG_NAME=$(echo "$RESPONSE" | grep -o '"tag_name": *"[^"]*"' | cut -d'"' -f4)
            VERSION=${TAG_NAME#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"
          
      - name: Install RPM build tools
        run: sudo apt-get update && sudo apt-get install -y rpm

      - name: Download Linux binary
        uses: robinraju/release-downloader@v1.8
        with:
          repository: ${{ github.repository }}
          tag: "v${{ steps.extract_version.outputs.VERSION }}"
          fileName: "apisnip-linux-${{ matrix.arch }}.tar.gz"
          out-file-path: ./downloaded
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify downloaded file
        run: |
          ls -la ./downloaded/
          if [ ! -s ./downloaded/apisnip-linux-*.tar.gz ]; then
            echo "Error: Downloaded file is empty or does not exist"
            exit 1
          fi
          file ./downloaded/apisnip-linux-*.tar.gz

      - name: Setup RPM build environment
        run: |
          mkdir -p ~/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
          mkdir -p ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}
          
          # Extract binary
          mkdir -p ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}/usr/bin
          mkdir -p ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}/usr/share/doc/apisnip
          tar -xzf ./downloaded/apisnip-linux-*.tar.gz -C ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}/usr/bin apisnip
          cp README.md LICENSE ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}/usr/share/doc/apisnip/ || true
          chmod +x ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}/usr/bin/apisnip
          
          # Create source tarball
          cd ~/rpmbuild/SOURCES
          tar -czf apisnip-${{ steps.extract_version.outputs.VERSION }}.tar.gz apisnip-${{ steps.extract_version.outputs.VERSION }}

      - name: Create spec file
        run: |
          cat > ~/rpmbuild/SPECS/apisnip.spec << EOF
          Name:           apisnip
          Version:        ${{ steps.extract_version.outputs.VERSION }}
          Release:        1%{?dist}
          Summary:        A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size
          
          License:        MIT
          URL:            https://github.com/Tuurlijk/apisnip
          Source0:        %{name}-%{version}.tar.gz
          
          # Specify architecture explicitly without macros that might cause issues
          BuildArch:      ${{ matrix.arch }}
          
          %description
          ApiSnip is a command-line tool that helps you trim down large OpenAPI specifications
          to only the parts you need. It provides a user-friendly terminal interface for
          selecting specific endpoints and data models.
          
          %prep
          %setup -q
          
          %install
          mkdir -p %{buildroot}
          cp -a * %{buildroot}
          
          %files
          %{_bindir}/apisnip
          %doc %{_docdir}/apisnip/README.md
          %license %{_docdir}/apisnip/LICENSE
          
          %changelog
          * $(date '+%a %b %d %Y') GitHub Action <apisnip.zumble.frap@michielroos.com> - ${{ steps.extract_version.outputs.VERSION }}-1
          - Automated package build
          EOF

      - name: Build RPM package
        id: build_rpm
        run: |
          rpmbuild -ba ~/rpmbuild/SPECS/apisnip.spec || {
            echo "RPM build failed, checking issues..."
            cat ~/rpmbuild/SPECS/apisnip.spec
            ls -la ~/rpmbuild/SOURCES/
            echo "Contents of source tarball:"
            tar -tvzf ~/rpmbuild/SOURCES/apisnip-${{ steps.extract_version.outputs.VERSION }}.tar.gz
            exit 1
          }
          
          # Find the built RPM
          RPM_PATH=$(find ~/rpmbuild/RPMS -name "*.rpm" | head -1)
          if [ -z "$RPM_PATH" ]; then
            echo "No RPM package found in the build directory"
            exit 1
          fi
          
          RPM_FILENAME=$(basename "$RPM_PATH")
          cp "$RPM_PATH" .
          
          # Create checksum
          sha256sum "${RPM_FILENAME}" > "${RPM_FILENAME}.sha256"
          
          echo "RPM_FILENAME=${RPM_FILENAME}" >> $GITHUB_OUTPUT

      - name: Upload RPM package to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.build_rpm.outputs.RPM_FILENAME }}
            ${{ steps.build_rpm.outputs.RPM_FILENAME }}.sha256
          tag_name: v${{ steps.extract_version.outputs.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-apk-package:
    name: Create Alpine Linux Package (APK)
    runs-on: ubuntu-latest
    # Only build for x86_64 as aarch64 is causing issues
    strategy:
      matrix:
        arch: [x86_64]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            # Extract version from the release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # If we got here, we need to manually get the latest release
            REPO="${GITHUB_REPOSITORY}"
            GITHUB_API="https://api.github.com/repos/${REPO}/releases/latest"
            VERSION=$(curl -s ${GITHUB_API} | jq -r '.tag_name' | sed 's/^v//')
            echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          fi
          VERSION=$(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)
          echo "Using version: $VERSION"
          # Export as environment variable for easier use in subsequent steps
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Download Linux binary
        uses: robinraju/release-downloader@v1.8
        with:
          repository: ${{ github.repository }}
          tag: "v${{ env.VERSION }}"
          fileName: "apisnip-linux-${{ matrix.arch }}.tar.gz"
          out-file-path: ./downloaded
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify downloaded file
        run: |
          ls -la ./downloaded/
          if [ ! -s ./downloaded/apisnip-linux-*.tar.gz ]; then
            echo "Error: Downloaded file is empty or does not exist"
            exit 1
          fi
          file ./downloaded/apisnip-linux-*.tar.gz

      # Create .deb package as a fallback for Alpine Linux
      - name: Create Debian package instead
        id: create_deb
        run: |
          # Extract the binary
          mkdir -p pkg/usr/bin
          mkdir -p pkg/usr/share/doc/apisnip
          tar -xzf ./downloaded/apisnip-linux-*.tar.gz -C pkg
          
          # Make sure binary is in the right place
          if [ -f "pkg/apisnip" ]; then
            mkdir -p pkg/usr/bin
            mv pkg/apisnip pkg/usr/bin/
          fi
          
          cp README.md LICENSE pkg/usr/share/doc/apisnip/ || true
          chmod +x pkg/usr/bin/apisnip
          
          # Create Debian control file
          mkdir -p pkg/DEBIAN
          cat > pkg/DEBIAN/control << EOF
          Package: apisnip
          Version: ${{ env.VERSION }}
          Section: utils
          Priority: optional
          Architecture: amd64
          Maintainer: Michiel Roos <apisnip.zumble.frap@michielroos.com>
          Description: A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size
           ApiSnip is a command-line tool that helps you trim down large OpenAPI specifications
           to only the parts you need. It provides a user-friendly terminal interface for
           selecting specific endpoints and data models.
          EOF
          
          # Build the package
          DEB_FILENAME="apisnip-alpine-${{ env.VERSION }}-${{ matrix.arch }}.deb"
          dpkg-deb --build pkg "${DEB_FILENAME}"
          echo "DEB_FILENAME=${DEB_FILENAME}" >> $GITHUB_OUTPUT
          
          # Create checksum
          sha256sum "${DEB_FILENAME}" > "${DEB_FILENAME}.sha256"

      - name: Upload Debian package to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.create_deb.outputs.DEB_FILENAME }}
            ${{ steps.create_deb.outputs.DEB_FILENAME }}.sha256
          tag_name: v${{ env.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-macos-package:
    name: Create macOS Package
    runs-on: macos-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Get latest release
        id: get_release
        if: github.event.inputs.version == ''
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/releases/latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            # Extract version from the release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Extract from API response with safer parsing
            RESPONSE='${{ steps.get_release.outputs.data }}'
            TAG_NAME=$(echo "$RESPONSE" | grep -o '"tag_name": *"[^"]*"' | cut -d'"' -f4)
            VERSION=${TAG_NAME#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"

      - name: Download macOS binaries
        uses: robinraju/release-downloader@v1.8
        with:
          repository: ${{ github.repository }}
          tag: "v${{ steps.extract_version.outputs.VERSION }}"
          fileName: "apisnip-macos-*.tar.gz"
          out-file-path: ./downloaded
          token: ${{ secrets.GITHUB_TOKEN }}

      # Create DMG package
      - name: Create macOS DMG package
        id: create_dmg
        run: |
          # Create app structure
          mkdir -p ApiSnip.app/Contents/{MacOS,Resources}
          
          # Extract x86_64 binary (use arm64 if available)
          if [ -f "downloaded/apisnip-macos-arm64.tar.gz" ]; then
            tar -xzf downloaded/apisnip-macos-arm64.tar.gz -C ./
          else
            tar -xzf downloaded/apisnip-macos-x86_64.tar.gz -C ./
          fi
          
          # Copy binary to app bundle
          mv apisnip ApiSnip.app/Contents/MacOS/
          
          # Create Info.plist
          cat > ApiSnip.app/Contents/Info.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleExecutable</key>
              <string>apisnip</string>
              <key>CFBundleIdentifier</key>
              <string>com.michielroos.apisnip</string>
              <key>CFBundleName</key>
              <string>ApiSnip</string>
              <key>CFBundleVersion</key>
              <string>${{ steps.extract_version.outputs.VERSION }}</string>
              <key>CFBundleShortVersionString</key>
              <string>${{ steps.extract_version.outputs.VERSION }}</string>
          </dict>
          </plist>
          EOF
          
          # Create DMG
          hdiutil create -volname "ApiSnip" -srcfolder ApiSnip.app -ov -format UDZO apisnip-${{ steps.extract_version.outputs.VERSION }}.dmg
          
          # Create checksum
          shasum -a 256 apisnip-${{ steps.extract_version.outputs.VERSION }}.dmg > apisnip-${{ steps.extract_version.outputs.VERSION }}.dmg.sha256
          
          echo "DMG_FILENAME=apisnip-${{ steps.extract_version.outputs.VERSION }}.dmg" >> $GITHUB_OUTPUT

      # Create Homebrew Formula
      - name: Create Homebrew Formula
        id: create_homebrew
        run: |
          # Create formula directory
          mkdir -p homebrew-formula
          
          # Calculate SHA for macOS binaries
          ARM64_SHA=""
          X86_64_SHA=""
          
          if [ -f "downloaded/apisnip-macos-arm64.tar.gz" ]; then
            ARM64_SHA=$(shasum -a 256 downloaded/apisnip-macos-arm64.tar.gz | cut -d ' ' -f 1)
          fi
          
          if [ -f "downloaded/apisnip-macos-x86_64.tar.gz" ]; then
            X86_64_SHA=$(shasum -a 256 downloaded/apisnip-macos-x86_64.tar.gz | cut -d ' ' -f 1)
          fi
          
          # Create the formula file
          cat > homebrew-formula/apisnip.rb << EOF
          class Apisnip < Formula
            desc "A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size"
            homepage "https://github.com/Tuurlijk/apisnip"
            version "${{ steps.extract_version.outputs.VERSION }}"
            license "MIT"
            
            on_macos do
              on_arm do
                url "https://github.com/Tuurlijk/apisnip/releases/download/v${{ steps.extract_version.outputs.VERSION }}/apisnip-macos-arm64.tar.gz"
                sha256 "${ARM64_SHA}"
              end
              
              on_intel do
                url "https://github.com/Tuurlijk/apisnip/releases/download/v${{ steps.extract_version.outputs.VERSION }}/apisnip-macos-x86_64.tar.gz"
                sha256 "${X86_64_SHA}"
              end
            end
            
            on_linux do
              url "https://github.com/Tuurlijk/apisnip/releases/download/v${{ steps.extract_version.outputs.VERSION }}/apisnip-linux-x86_64.tar.gz"
            end
            
            def install
              bin.install "apisnip"
            end
            
            test do
              assert_match "ApiSnip ${{ steps.extract_version.outputs.VERSION }}", shell_output("#{bin}/apisnip --version", 2)
            end
          end
          EOF
          
          # Create a zip of the formula
          zip -r apisnip-homebrew-${{ steps.extract_version.outputs.VERSION }}.zip homebrew-formula/apisnip.rb
          
          echo "HOMEBREW_FORMULA=apisnip-homebrew-${{ steps.extract_version.outputs.VERSION }}.zip" >> $GITHUB_OUTPUT

      - name: Upload macOS packages to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.create_dmg.outputs.DMG_FILENAME }}
            ${{ steps.create_dmg.outputs.DMG_FILENAME }}.sha256
            ${{ steps.create_homebrew.outputs.HOMEBREW_FORMULA }}
          tag_name: v${{ steps.extract_version.outputs.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-aur-package:
    name: Create AUR Package
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Get latest release
        id: get_release
        if: github.event.inputs.version == ''
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/releases/latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            # Extract version from the release tag
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Extract from API response with safer parsing
            RESPONSE='${{ steps.get_release.outputs.data }}'
            TAG_NAME=$(echo "$RESPONSE" | grep -o '"tag_name": *"[^"]*"' | cut -d'"' -f4)
            VERSION=${TAG_NAME#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"
          
      - name: Download source code
        run: |
          mkdir -p aur-package
          cd aur-package
          curl -L "https://github.com/${{ github.repository }}/archive/refs/tags/v${{ steps.extract_version.outputs.VERSION }}.tar.gz" -o "apisnip-${{ steps.extract_version.outputs.VERSION }}.tar.gz"
          
          # Calculate SHA256 sum
          SOURCE_SHA256=$(sha256sum "apisnip-${{ steps.extract_version.outputs.VERSION }}.tar.gz" | awk '{print $1}')
          echo "SOURCE_SHA256=${SOURCE_SHA256}" >> $GITHUB_ENV

      - name: Create PKGBUILD
        id: create_pkgbuild
        run: |
          cd aur-package
          
          cat > PKGBUILD << EOF
          # Maintainer: Michiel Roos <apisnip.zumble.frap@michielroos.com>
          
          pkgname=apisnip
          pkgver=${{ steps.extract_version.outputs.VERSION }}
          pkgrel=1
          pkgdesc="A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size"
          arch=('x86_64' 'aarch64')
          url="https://github.com/Tuurlijk/apisnip"
          license=('MIT')
          depends=()
          makedepends=('cargo')
          source=("\${pkgname}-\${pkgver}.tar.gz::https://github.com/Tuurlijk/apisnip/archive/refs/tags/v\${pkgver}.tar.gz")
          sha256sums=('${SOURCE_SHA256}')
          
          build() {
            cd "\${pkgname}-\${pkgver}"
            cargo build --release
          }
          
          package() {
            cd "\${pkgname}-\${pkgver}"
            install -Dm755 "target/release/\${pkgname}" "\${pkgdir}/usr/bin/\${pkgname}"
            install -Dm644 "LICENSE" "\${pkgdir}/usr/share/licenses/\${pkgname}/LICENSE"
            install -Dm644 "README.md" "\${pkgdir}/usr/share/doc/\${pkgname}/README.md"
          }
          EOF
          
          cat > .SRCINFO << EOF
          pkgbase = apisnip
          	pkgdesc = A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size
          	pkgver = ${{ steps.extract_version.outputs.VERSION }}
          	pkgrel = 1
          	url = https://github.com/Tuurlijk/apisnip
          	arch = x86_64
          	arch = aarch64
          	license = MIT
          	makedepends = cargo
          	source = apisnip-${{ steps.extract_version.outputs.VERSION }}.tar.gz::https://github.com/Tuurlijk/apisnip/archive/refs/tags/v${{ steps.extract_version.outputs.VERSION }}.tar.gz
          	sha256sums = ${SOURCE_SHA256}
          
          pkgname = apisnip
          EOF
          
          tar -czf apisnip-aur-${{ steps.extract_version.outputs.VERSION }}.tar.gz PKGBUILD .SRCINFO
          echo "AUR_PACKAGE=apisnip-aur-${{ steps.extract_version.outputs.VERSION }}.tar.gz" >> $GITHUB_OUTPUT

      - name: Upload AUR package to release
        uses: softprops/action-gh-release@v2
        with:
          files: aur-package/${{ steps.create_pkgbuild.outputs.AUR_PACKAGE }}
          tag_name: v${{ steps.extract_version.outputs.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      # Note: To actually publish to AUR, you would need to set up SSH keys
      # and use git to push to the AUR. This is not implemented here as it
      # requires AUR account credentials. 

  # Add a final job to organize release assets in the description
  organize-release-assets:
    name: Organize Release Assets
    needs: [create-debian-package, create-rpm-package, create-aur-package, create-macos-package]
    # Skip the failing APK package job
    runs-on: ubuntu-latest
    if: always() # Run even if some of the previous jobs failed
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract Version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Get latest release tag
            REPO="${GITHUB_REPOSITORY}"
            GITHUB_API="https://api.github.com/repos/${REPO}/releases/latest"
            VERSION=$(curl -s ${GITHUB_API} -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" | jq -r '.tag_name' | sed 's/^v//')
            echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"
          echo "VERSION=$(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)" >> $GITHUB_ENV

      - name: Get All Assets
        id: get_assets
        run: |
          RELEASE_TAG="v${VERSION}"
          ASSETS=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$RELEASE_TAG" \
            | jq -r '.assets[] | "\(.name) \(.browser_download_url)"')
          
          echo "ASSETS<<EOF" >> $GITHUB_ENV
          echo "$ASSETS" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Get Existing Release ID
        id: get_release_id
        run: |
          RELEASE_TAG="v${VERSION}"
          RELEASE_DATA=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$RELEASE_TAG")
          
          RELEASE_ID=$(echo "$RELEASE_DATA" | jq -r '.id')
          EXISTING_BODY=$(echo "$RELEASE_DATA" | jq -r '.body // ""')
          
          echo "RELEASE_ID=$RELEASE_ID" >> $GITHUB_OUTPUT
          
          # Check if body already contains our asset tables (to avoid duplicates)
          if echo "$EXISTING_BODY" | grep -q "## Binary Downloads"; then
            # If our sections already exist, just preserve the original body
            echo "EXISTING_BODY<<EOF" >> $GITHUB_ENV
            echo "$EXISTING_BODY" >> $GITHUB_ENV 
            echo "EOF" >> $GITHUB_ENV
            echo "CONTAINS_ASSETS=true" >> $GITHUB_OUTPUT
          else
            # If our sections don't exist, we'll append them
            echo "EXISTING_BODY<<EOF" >> $GITHUB_ENV
            echo "$EXISTING_BODY" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "CONTAINS_ASSETS=false" >> $GITHUB_OUTPUT
          fi

      - name: Organize Assets by Category
        id: organize_assets
        if: steps.get_release_id.outputs.CONTAINS_ASSETS != 'true'
        run: |
          # Function to create a category section with assets
          create_category() {
            local category=$1
            local pattern=$2
            local title=$3
            
            echo -e "### $title\n"
            
            # Filter assets matching the pattern and create markdown links
            matching_assets=$(echo "$ASSETS" | grep -i "$pattern" | grep -v "\.sha256$" | sort)
            if [ -z "$matching_assets" ]; then
              echo "No $category packages available."
            else
              echo "| Package | SHA256 |"
              echo "|---------|--------|"
              echo "$matching_assets" | while read -r line; do
                name=$(echo "$line" | awk '{print $1}')
                url=$(echo "$line" | awk '{print $2}')
                sha_line=$(echo "$ASSETS" | grep "${name}\.sha256")
                if [ -n "$sha_line" ]; then
                  sha_url=$(echo "$sha_line" | awk '{print $2}')
                  echo "| [$name]($url) | [SHA256]($sha_url) |"
                else
                  echo "| [$name]($url) | N/A |"
                fi
              done
            fi
            echo ""
          }
          
          # Create temporary markdown files for each category
          TMP_DIR=$(mktemp -d)
          
          # Linux Binaries
          create_category "Linux" "linux" "Linux Binaries" > "$TMP_DIR/linux.md"
          
          # Windows Binaries
          create_category "Windows" "windows" "Windows Binaries" > "$TMP_DIR/windows.md"
          
          # macOS Binaries
          create_category "macOS" "macos" "macOS Binaries" > "$TMP_DIR/macos.md"
          
          # FreeBSD Binaries
          create_category "FreeBSD" "freebsd" "FreeBSD Binaries" > "$TMP_DIR/freebsd.md"
          
          # NetBSD Binaries
          create_category "NetBSD" "netbsd" "NetBSD Binaries" > "$TMP_DIR/netbsd.md"
          
          # Debian/Ubuntu Packages
          create_category "Debian" "_amd64\.deb\|_arm64\.deb\|_i386\.deb" "Debian/Ubuntu Packages (.deb)" > "$TMP_DIR/debian.md"
          
          # RPM Packages
          create_category "RPM" "\.rpm" "Red Hat/Fedora/SUSE Packages (.rpm)" > "$TMP_DIR/rpm.md"
          
          # AUR Package
          create_category "AUR" "aur" "Arch Linux Package (AUR)" > "$TMP_DIR/aur.md"
          
          # Homebrew Formula
          create_category "Homebrew" "homebrew" "macOS Homebrew Formula" > "$TMP_DIR/homebrew.md"
          
          # DMG Package
          create_category "DMG" "\.dmg" "macOS Disk Image (.dmg)" > "$TMP_DIR/dmg.md"
          
          # Snap Package
          create_category "Snap" "\.snap" "Snap Packages" > "$TMP_DIR/snap.md"
          
          # Nix Package
          create_category "Nix" "\.nix" "Nix Packages" > "$TMP_DIR/nix.md"
          
          # Combine all sections
          {
            echo -e "\n## Binary Downloads\n"
            cat "$TMP_DIR/linux.md"
            cat "$TMP_DIR/windows.md"
            cat "$TMP_DIR/macos.md"
            cat "$TMP_DIR/freebsd.md"
            cat "$TMP_DIR/netbsd.md"
            
            echo -e "## Package Downloads\n"
            cat "$TMP_DIR/debian.md"
            cat "$TMP_DIR/rpm.md"
            cat "$TMP_DIR/aur.md"
            cat "$TMP_DIR/homebrew.md"
            cat "$TMP_DIR/dmg.md"
            cat "$TMP_DIR/snap.md"
            cat "$TMP_DIR/nix.md"
          } > assets_section.md
          
          # Combine existing body with asset tables
          if [ -n "$EXISTING_BODY" ]; then
            COMBINED_BODY="${EXISTING_BODY}$(cat assets_section.md)"
          else
            COMBINED_BODY="## ApiSnip v${VERSION}"
            COMBINED_BODY="${COMBINED_BODY}\n\n"
            COMBINED_BODY="${COMBINED_BODY}A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size ✂️"
            COMBINED_BODY="${COMBINED_BODY}\n\n"
            COMBINED_BODY="${COMBINED_BODY}$(cat assets_section.md)"
          fi
          
          echo "$COMBINED_BODY" > combined_body.md

      - name: Update Release Description
        if: steps.get_release_id.outputs.CONTAINS_ASSETS != 'true'
        run: |
          RELEASE_ID="${{ steps.get_release_id.outputs.RELEASE_ID }}"
          
          # Use GitHub CLI to update the release body
          gh api \
            --method PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/releases/$RELEASE_ID \
            -f body="$(cat combined_body.md)"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Log Status
        run: |
          if [ "${{ steps.get_release_id.outputs.CONTAINS_ASSETS }}" == "true" ]; then
            echo "Release description already contains asset tables. No changes made."
          else
            echo "Release description updated with organized asset tables."
          fi

  # Add new Snap Package job
  create-snap-package:
    name: Create Snap Package
    runs-on: ubuntu-latest
    needs: [create-debian-package] # Depends on Debian package for metadata
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Get latest release tag
            REPO="${GITHUB_REPOSITORY}"
            GITHUB_API="https://api.github.com/repos/${REPO}/releases/latest"
            VERSION=$(curl -s ${GITHUB_API} -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" | jq -r '.tag_name' | sed 's/^v//')
            echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"
          echo "VERSION=$(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)" >> $GITHUB_ENV

      - name: Install Snapcraft
        run: |
          sudo snap install snapcraft --classic
          sudo apt-get update
          sudo apt-get install -y curl jq

      - name: Download Linux binary
        uses: robinraju/release-downloader@v1.8
        with:
          repository: ${{ github.repository }}
          tag: "v${{ env.VERSION }}"
          fileName: "apisnip-linux-x86_64.tar.gz"
          out-file-path: ./downloaded
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Snap directory structure
        run: |
          mkdir -p apisnip/snap/local/
          mkdir -p apisnip/meta/gui
          
          # Extract binary
          mkdir -p apisnip/bin
          tar -xzf ./downloaded/apisnip-linux-x86_64.tar.gz -C apisnip
          
          # Move binary to the right place
          if [ -f "apisnip/apisnip" ]; then
            mv apisnip/apisnip apisnip/bin/
          elif [ -f "apisnip/usr/bin/apisnip" ]; then
            mkdir -p apisnip/bin
            mv apisnip/usr/bin/apisnip apisnip/bin/
          fi
          
          # Ensure binary is executable
          chmod +x apisnip/bin/apisnip
          
          # Create snap.yaml
          cat > apisnip/meta/snap.yaml << EOF
          name: apisnip
          version: ${{ env.VERSION }}
          summary: A terminal user interface (TUI) tool for trimming OpenAPI specifications
          description: |
            ApiSnip is a command-line tool that helps you trim down large OpenAPI specifications
            to only the parts you need. It provides a user-friendly terminal interface for
            selecting specific endpoints and data models.
          
          grade: stable
          confinement: strict
          base: core20
          
          apps:
            apisnip:
              command: bin/apisnip
              plugs:
                - home
                - network
                - network-bind
          EOF
          
          # Create snapcraft.yaml
          cat > apisnip/snap/snapcraft.yaml << EOF
          name: apisnip
          version: ${{ env.VERSION }}
          summary: A terminal user interface (TUI) tool for trimming OpenAPI specifications
          description: |
            ApiSnip is a command-line tool that helps you trim down large OpenAPI specifications
            to only the parts you need. It provides a user-friendly terminal interface for
            selecting specific endpoints and data models.
          
          base: core20
          confinement: strict
          grade: stable
          
          parts:
            apisnip:
              plugin: dump
              source: .
              stage-packages:
                - libssl1.1
                - ca-certificates
          
          apps:
            apisnip:
              command: bin/apisnip
              plugs:
                - home
                - network
                - network-bind
          EOF

      - name: Build Snap package
        id: build_snap
        run: |
          cd apisnip
          snapcraft
          
          # Find the snap file
          SNAP_FILE=$(find . -name "*.snap" | head -1)
          if [ -z "$SNAP_FILE" ]; then
            echo "Error: No snap file found"
            exit 1
          fi
          
          # Copy snap file to workspace root
          cp "$SNAP_FILE" ../
          cd ..
          
          # Get the filename
          SNAP_FILENAME=$(basename "$SNAP_FILE")
          echo "SNAP_FILENAME=$SNAP_FILENAME" >> $GITHUB_OUTPUT
          
          # Create checksum
          sha256sum "$SNAP_FILENAME" > "${SNAP_FILENAME}.sha256"

      - name: Upload Snap package to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.build_snap.outputs.SNAP_FILENAME }}
            ${{ steps.build_snap.outputs.SNAP_FILENAME }}.sha256
          tag_name: v${{ env.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Add new Nix Package job
  create-nix-package:
    name: Create Nix Package
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract version
        id: extract_version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            # Get latest release tag
            REPO="${GITHUB_REPOSITORY}"
            GITHUB_API="https://api.github.com/repos/${REPO}/releases/latest"
            VERSION=$(curl -s ${GITHUB_API} -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" | jq -r '.tag_name' | sed 's/^v//')
            echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          fi
          echo "Using version: $(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)"
          echo "VERSION=$(cat $GITHUB_OUTPUT | grep VERSION | cut -d= -f2)" >> $GITHUB_ENV

      - name: Download source code
        run: |
          mkdir -p nix-package
          cd nix-package
          curl -L "https://github.com/${{ github.repository }}/archive/refs/tags/v${{ env.VERSION }}.tar.gz" -o "apisnip-${{ env.VERSION }}.tar.gz"
          
          # Calculate SHA256 sum
          SOURCE_SHA256=$(sha256sum "apisnip-${{ env.VERSION }}.tar.gz" | awk '{print $1}')
          echo "SOURCE_SHA256=${SOURCE_SHA256}" >> $GITHUB_ENV

      - name: Create Nix package file
        id: create_nix
        run: |
          cd nix-package
          
          # Create default.nix
          cat > default.nix << EOF
          { pkgs ? import <nixpkgs> {} }:
          
          pkgs.rustPlatform.buildRustPackage rec {
            pname = "apisnip";
            version = "${{ env.VERSION }}";
          
            src = pkgs.fetchFromGitHub {
              owner = "Tuurlijk";
              repo = "apisnip";
              rev = "v\${version}";
              sha256 = "${{ env.SOURCE_SHA256 }}";
            };
          
            cargoSha256 = "${{ env.SOURCE_SHA256 }}";
          
            meta = with pkgs.lib; {
              description = "A terminal user interface (TUI) tool for trimming OpenAPI specifications down to size";
              homepage = "https://github.com/Tuurlijk/apisnip";
              license = licenses.mit;
              maintainers = [ maintainers.tuurlijk ];
              platforms = platforms.all;
            };
          }
          EOF
          
          # Create a README for the nix package
          cat > README.md << EOF
          # Nix Package for ApiSnip
          
          This is a Nix package definition for ApiSnip, a terminal user interface (TUI) tool for trimming OpenAPI specifications.
          
          ## Installation
          
          ### Temporary installation
          
          \`\`\`
          nix-shell -p 'import (builtins.fetchTarball "https://github.com/Tuurlijk/apisnip/releases/download/v${{ env.VERSION }}/apisnip-nix-${{ env.VERSION }}.tar.gz") {}'
          \`\`\`
          
          ### Permanent installation
          
          Add the following to your \`configuration.nix\`:
          
          \`\`\`nix
          let
            apisnip = import (builtins.fetchTarball "https://github.com/Tuurlijk/apisnip/releases/download/v${{ env.VERSION }}/apisnip-nix-${{ env.VERSION }}.tar.gz") {};
          in
          {
            environment.systemPackages = [ apisnip ];
          }
          \`\`\`
          
          Or for home-manager:
          
          \`\`\`nix
          let
            apisnip = import (builtins.fetchTarball "https://github.com/Tuurlijk/apisnip/releases/download/v${{ env.VERSION }}/apisnip-nix-${{ env.VERSION }}.tar.gz") {};
          in
          {
            home.packages = [ apisnip ];
          }
          \`\`\`
          EOF
          
          # Create the tarball
          NIX_FILENAME="apisnip-nix-${{ env.VERSION }}.tar.gz"
          tar -czf "$NIX_FILENAME" default.nix README.md
          echo "NIX_FILENAME=$NIX_FILENAME" >> $GITHUB_OUTPUT
          
          # Create checksum
          sha256sum "$NIX_FILENAME" > "${NIX_FILENAME}.sha256"

      - name: Upload Nix package to release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            nix-package/${{ steps.create_nix.outputs.NIX_FILENAME }}
            nix-package/${{ steps.create_nix.outputs.NIX_FILENAME }}.sha256
          tag_name: v${{ env.VERSION }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 